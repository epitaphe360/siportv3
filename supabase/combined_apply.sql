-- Combined apply script generated by assistant
-- Order: migrations, add_visitor_level, visitor function, enforce quota, rls recommendations, final fix, public rls fixes, checks

-- Begin combined script

-- === migrations/20250914000100_create_visitor_function.sql ===

-- Create a SECURITY DEFINER function to upsert a visitor bypassing RLS safely
-- Apply this in Supabase SQL Editor or via migrations

create or replace function public.create_visitor_safe(
  p_email text,
  p_name text,
  p_type text default 'visitor',
  p_visitor_level text default 'free',
  p_profile jsonb default '{}'::jsonb
)
returns public.users
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user public.users;
  v_type user_type;
begin
  -- Safe cast: if p_type is not a valid user_type enum label, fallback to 'visitor'
  begin
    v_type := coalesce(p_type, 'visitor')::user_type;
  exception when others then
    v_type := 'visitor'::user_type;
  end;

  insert into public.users (email, name, type, visitor_level, profile)
  values (p_email, p_name, v_type, coalesce(p_visitor_level, 'free'), p_profile)
  on conflict (email) do update set
    name = excluded.name,
    type = excluded.type,
    visitor_level = excluded.visitor_level,
    profile = excluded.profile
  returning * into v_user;

  return v_user;
end;
$$;

-- Restrict and grant execute to client roles (updated signature)
revoke all on function public.create_visitor_safe(text, text, text, text, jsonb) from public;
grant execute on function public.create_visitor_safe(text, text, text, text, jsonb) to anon, authenticated;


-- === supabase/add_visitor_level.sql ===

-- Ajoute le champ visitor_level à la table users
ALTER TABLE public.users ADD COLUMN IF NOT EXISTS visitor_level text;
-- Optionnel : index pour les recherches rapides
CREATE INDEX IF NOT EXISTS idx_users_visitor_level ON public.users(visitor_level);

-- Create a small lookup table for visitor level quotas
CREATE TABLE IF NOT EXISTS public.visitor_levels (
  level text PRIMARY KEY,
  quota int NOT NULL DEFAULT 0
);
INSERT INTO public.visitor_levels(level, quota) VALUES
  ('free',0),('basic',2),('premium',5),('vip',9999)
ON CONFLICT (level) DO UPDATE SET quota = EXCLUDED.quota;


-- === supabase/enforce_visitor_quota.sql ===

-- Enforce visitor appointment quotas at DB level
-- This trigger prevents inserting or updating an appointment to 'confirmed' when the visitor already
-- has reached the allowed number of confirmed appointments for their visitor_level.

CREATE OR REPLACE FUNCTION public.check_visitor_quota()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_level text;
  v_quota int := 0;
  confirmed_count int := 0;
BEGIN
  -- Only enforce when status becomes 'confirmed'
  IF (TG_OP = 'INSERT' AND NEW.status = 'confirmed') OR
     (TG_OP = 'UPDATE' AND NEW.status = 'confirmed' AND (OLD.status IS DISTINCT FROM 'confirmed')) THEN

    SELECT visitor_level INTO v_level FROM public.users WHERE id = NEW.visitor_id;
    IF v_level IS NULL OR v_level = '' THEN
      v_level := 'free';
    END IF;

    -- Read quotas from visitor_levels table (allows runtime updates)
    SELECT quota INTO v_quota FROM public.visitor_levels WHERE level = v_level;
    IF v_quota IS NULL THEN
      v_quota := 0;
    END IF;

    SELECT COUNT(*) INTO confirmed_count FROM public.appointments
      WHERE visitor_id = NEW.visitor_id AND status = 'confirmed';

    IF confirmed_count >= v_quota THEN
      RAISE EXCEPTION 'Quota RDV atteint pour votre niveau (%).', v_level;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- Attach trigger to appointments table for INSERT and UPDATE
DROP TRIGGER IF EXISTS trigger_check_visitor_quota ON public.appointments;
CREATE TRIGGER trigger_check_visitor_quota
  BEFORE INSERT OR UPDATE ON public.appointments
  FOR EACH ROW
  EXECUTE FUNCTION public.check_visitor_quota();


-- === supabase/rls_recommendations.sql ===

-- RLS recommendations for appointments table
-- These are example policies. Adapt role names and column names to your schema.

-- 1) Allow authenticated users to INSERT their own appointments
-- Assumes JWT `sub` maps to users.id and that anon/public role is restricted.

-- Enable RLS on table
ALTER TABLE IF EXISTS public.appointments ENABLE ROW LEVEL SECURITY;

-- Policy: allow users to insert their own appointments
DROP POLICY IF EXISTS "users_can_insert_own_appointments" ON public.appointments;
CREATE POLICY "users_can_insert_own_appointments"
  ON public.appointments
  FOR INSERT
  -- auth.uid() is text; cast to uuid to compare with visitor_id
  WITH CHECK (visitor_id = auth.uid()::uuid);

DROP POLICY IF EXISTS "users_can_select_own_appointments" ON public.appointments;
CREATE POLICY "users_can_select_own_appointments"
  ON public.appointments
  FOR SELECT
  USING (visitor_id = auth.uid()::uuid);

DROP POLICY IF EXISTS "users_can_update_own_status" ON public.appointments;
CREATE POLICY "users_can_update_own_status"
  ON public.appointments
  FOR UPDATE
  -- Ensure the row belongs to the user
  USING (visitor_id = auth.uid()::uuid)
  -- WITH CHECK limits the new row values: users can only change to safe statuses
  WITH CHECK (visitor_id = auth.uid()::uuid AND status IN ('pending','cancelled'));


-- === supabase/final_fix.sql ===

-- FINAL FIX (SAFE + REVERSIBLE)
-- 1) Ensure helper function is present (SECURITY DEFINER)
-- 2) Create a public_users view exposing only safe fields
-- 3) Remove any public policy on users and grant SELECT on public_users
-- 4) Ensure exhibitors/products/mini_sites have public read policies where appropriate

BEGIN;

-- 1) Helper
CREATE OR REPLACE FUNCTION public.is_admin(p_uid uuid) RETURNS boolean
LANGUAGE sql STABLE SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.users WHERE id = p_uid AND type = 'admin'
  );
$$;

-- 2) Create public_users view (adaptez les colonnes exposées selon vos besoins)
CREATE OR REPLACE VIEW public.public_users AS
SELECT id,
       name,
       NULL::text AS email, -- masqué par défaut
       profile->>'public_bio' AS public_bio
FROM public.users;

GRANT SELECT ON public.public_users TO public;

-- 3) Remove public policies on users (si existantes) and keep RLS active
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public can read users" ON public.users;
DROP POLICY IF EXISTS "Users can read own profile" ON public.users;
DROP POLICY IF EXISTS "Users can read own data" ON public.users;

-- Create admin policy for users (admins only, using is_admin)
DROP POLICY IF EXISTS "Admins can manage all users" ON public.users;
CREATE POLICY "Admins can manage all users" ON public.users
  FOR ALL
  TO authenticated
  -- is_admin expects uuid, cast auth.uid()
  USING (is_admin(auth.uid()::uuid));

-- 4) Public read policies for other tables
-- Exhibitors
ALTER TABLE public.exhibitors ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public can read exhibitors" ON public.exhibitors;
CREATE POLICY "Public can read exhibitors" ON public.exhibitors
  FOR SELECT
  TO public
  USING (true);

-- Products
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public can read products" ON public.products;
CREATE POLICY "Public can read products" ON public.products
  FOR SELECT
  TO public
  USING (true);

-- Mini-sites: only published
ALTER TABLE public.mini_sites ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public can read published mini-sites" ON public.mini_sites;
CREATE POLICY "Public can read published mini-sites" ON public.mini_sites
  FOR SELECT
  TO public
  USING (published = true);

COMMIT;

-- NOTES:
-- - Cette opération expose un view `public_users` contenant seulement des champs "sûrs".
-- - Si vous souhaitez exposer email ou autres champs, modifiez la view en connaissance de cause.
-- - Pour rollback, voir rollback_policies.sql (généré séparément).


-- === supabase/fix_public_rls.sql ===

-- Correction automatique des policies RLS pour accès public
-- 1. Exhibitors
ALTER TABLE exhibitors DISABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Anyone can read exhibitors" ON exhibitors;
DROP POLICY IF EXISTS "Public can read exhibitors" ON exhibitors;
ALTER TABLE exhibitors ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can read exhibitors"
  ON exhibitors
  FOR SELECT
  TO public
  USING (true);

-- 2. Products
ALTER TABLE products DISABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Anyone can read products" ON products;
DROP POLICY IF EXISTS "Public can read products" ON products;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can read products"
  ON products
  FOR SELECT
  TO public
  USING (true);

-- 3. Mini-sites
ALTER TABLE mini_sites DISABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Anyone can read mini-sites" ON mini_sites;
DROP POLICY IF EXISTS "Public can read mini-sites" ON mini_sites;
DROP POLICY IF EXISTS "Anyone can read published mini-sites" ON mini_sites;
DROP POLICY IF EXISTS "Public can read published mini-sites" ON mini_sites;
ALTER TABLE mini_sites ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can read published mini-sites"
  ON mini_sites
  FOR SELECT
  TO public
  USING (published = true);

-- 4. Users (lecture profil propre uniquement)
ALTER TABLE users DISABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can read own profile" ON users;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can read own profile"
  ON users
  FOR SELECT
  TO authenticated
  USING (auth.uid()::uuid = id);

-- 5. Events (si table existe)
ALTER TABLE events DISABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Anyone can read events" ON events;
DROP POLICY IF EXISTS "Public can read events" ON events;
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public can read events"
  ON events
  FOR SELECT
  TO public
  USING (true);

-- 6. Partners (lecture des partenaires vérifiés)
ALTER TABLE partners DISABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Anyone can read verified partners" ON partners;
ALTER TABLE partners ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Anyone can read verified partners"
  ON partners
  FOR SELECT
  TO public
  USING (verified = true);

-- 7. Conversations/messages (lecture publique désactivée, accès authentifié seulement)
-- Ajoutez ici si besoin

-- Fin de la correction automatique


-- === supabase/check_policies.sql ===

-- Quick checks for final_fix.sql
-- Run these queries in Supabase SQL editor.

-- 1) As anon (no special role) - use the REST API or run via SQL as anon key mimic
--    Check that exhibitors are readable:
SELECT count(*) AS exhibitors_count FROM public.exhibitors;

-- 2) Check that mini_sites only returns published records
SELECT id, published FROM public.mini_sites LIMIT 10;

-- 3) Verify public_users view exists and is safe
SELECT column_name, data_type FROM information_schema.columns
WHERE table_schema = 'public' AND table_name = 'public_users';

-- 4) Test is_admin function (replace with a known admin uuid if available)
-- SELECT public.is_admin('00000000-0000-0000-0000-000000000000');

-- 5) Verify policies present for tables
SELECT pol.polname AS policy_name, tbl.relname AS table_name
FROM pg_policy pol
JOIN pg_class tbl ON pol.polrelid = tbl.oid
WHERE tbl.relname IN ('exhibitors','products','mini_sites','users');


-- === supabase/rollback_policies.sql ===

-- Rollback for final_fix.sql
-- This script attempts to revert the changes made by `final_fix.sql`.
-- Run in Supabase SQL editor if you need to restore previous policy state.

BEGIN;

-- 1) Revoke public SELECT on public_users and drop view
REVOKE SELECT ON public.public_users FROM public;
DROP VIEW IF EXISTS public.public_users;

-- 2) Drop admin helper function
-- Remove policies that depend on is_admin to allow dropping the function safely
DROP POLICY IF EXISTS "Admins can manage all exhibitors" ON public.exhibitors;
DROP POLICY IF EXISTS "Admins can manage all mini-sites" ON public.mini_sites;
DROP POLICY IF EXISTS "Admins can manage all products" ON public.products;
DROP POLICY IF EXISTS "Admins can manage all users" ON public.users;
DROP FUNCTION IF EXISTS public.is_admin(uuid);

-- 3) Remove policies created by final_fix.sql (they are dropped if exist)
ALTER TABLE IF EXISTS public.exhibitors ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public can read exhibitors" ON public.exhibitors;

ALTER TABLE IF EXISTS public.products ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public can read products" ON public.products;

ALTER TABLE IF EXISTS public.mini_sites ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public can read published mini-sites" ON public.mini_sites;

DROP POLICY IF EXISTS "Admins can manage all users" ON public.users;
-- Note: this rollback will NOT restore any custom policies that existed prior to
-- running final_fix.sql. If you had bespoke rules, re-create them manually.

COMMIT;

-- After running this, re-create any prior policies you want. Keep backups of your
-- original policies before applying fixes.
-- ROLLBACK: revert final_fix.sql changes
BEGIN;

-- Drop helper
DROP FUNCTION IF EXISTS public.is_admin(uuid) CASCADE;

-- Drop public view
DROP VIEW IF EXISTS public.public_users CASCADE;

-- Remove public read policies added earlier
DROP POLICY IF EXISTS "Public can read exhibitors" ON public.exhibitors;
DROP POLICY IF EXISTS "Public can read products" ON public.products;
DROP POLICY IF EXISTS "Public can read published mini-sites" ON public.mini_sites;

-- NOTE: This rollback does not restore prior policy definitions. If vous voulez
-- restaurer les anciennes policies, fournissez les exports précédents et je
-- générerai un script de restauration complet.

COMMIT;

-- End of combined script
